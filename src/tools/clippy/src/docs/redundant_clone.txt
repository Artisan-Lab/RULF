### What it does
Checks for a redundant `clone()` (and its relatives) which clones an owned
value that is going to be dropped without further use.

### Why is this bad?
It is not always possible for the compiler to eliminate useless
allocations and deallocations generated by redundant `clone()`s.

### Known problems
False-negatives: analysis performed by this lint is conservative and limited.

### Example
```
{
    let x = Foo::new();
    call(x.clone());
    call(x.clone()); // this can just pass `x`
}

["lorem", "ipsum"].join(" ").to_string();

Path::new("/a/b").join("c").to_path_buf();
```